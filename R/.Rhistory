}
linear_model(lm_patho$y~.,data=lm_patho)
linear_model(y~.,data=lm_patho)
load("/Users/shawnieshan/Desktop/BIS557/bis557/data/lm_patho.rda")
#lmod<-lm(lm_patho$y~.,data=lm_patho)
#summary(lmod)
linear_model <- function(formula, data) {
#browser()
all<-all.vars(formula)
x<-model.matrix(formula, data)
y<-data[,all[1]]
#svd_output <- svd(x)
#U <- svd_output[["u"]]
#Sinv <- diag(1 / svd_output[["d"]])
#V <- svd_output[["v"]]
#pseudo_inv <- V %*% Sinv %*% t(U)
#betahat <- pseudo_inv %*% y
#colnames(betahat) <- "regression coefficient"
#rownames(betahat) <- c("Sepal.Width","Patal.Length","Petal.Width","Species_versicolor","Species_virginica")
#print(betahat)
#lm(formula, data)
beta<-list()
beta$coefficients=qr.coef(qr(x),y)
class(beta)="lm"
return(beta)
}
linear_model(y~.,data=lm_patho)
load("/Users/shawnieshan/Desktop/BIS557/bis557/data/lm_patho.rda")
#lmod<-lm(lm_patho$y~.,data=lm_patho)
#summary(lmod)
linear_model <- function(formula, data) {
#browser()
all<-all.vars(formula)
x<-model.matrix(formula, data)
y<-data[,all[1]]
#svd_output <- svd(x)
#U <- svd_output[["u"]]
#Sinv <- diag(1 / svd_output[["d"]])
#V <- svd_output[["v"]]
#pseudo_inv <- V %*% Sinv %*% t(U)
#betahat <- pseudo_inv %*% y
#colnames(betahat) <- "regression coefficient"
#rownames(betahat) <- c("Sepal.Width","Patal.Length","Petal.Width","Species_versicolor","Species_virginica")
#print(betahat)
#lm(formula, data)
beta<-list()
beta$coefficients=qr.coef(qr(x),y)
class(beta)="lm"
return(beta)
}
linear_model(y~.,data=lm_patho)
library(testthat)
test()
install.packages(testthat)
install.packages("testthat")
library(test)
test()
install.packages("test")
library(test)
test()
linear_model <- function(formula, data) {
#browser()
all<-all.vars(formula)
x<-model.matrix(formula, data)
y<-data[,all[1]]
#svd_output <- svd(x)
#U <- svd_output[["u"]]
#Sinv <- diag(1 / svd_output[["d"]])
#V <- svd_output[["v"]]
#pseudo_inv <- V %*% Sinv %*% t(U)
#betahat <- pseudo_inv %*% y
#colnames(betahat) <- "regression coefficient"
#rownames(betahat) <- c("Sepal.Width","Patal.Length","Petal.Width","Species_versicolor","Species_virginica")
#print(betahat)
#lm(formula, data)
beta<-list()
beta$call=call("linear_model", formula)
beta$coefficients=qr.coef(qr(x),y)
class(beta)="lm"
return(beta)
}
linear_model(y~.,data=lm_patho)
linear_model <- function(formula, data) {
#browser()
all<-all.vars(formula)
x<-model.matrix(formula, data)
y<-data[,all[1]]
#svd_output <- svd(x)
#U <- svd_output[["u"]]
#Sinv <- diag(1 / svd_output[["d"]])
#V <- svd_output[["v"]]
#pseudo_inv <- V %*% Sinv %*% t(U)
#betahat <- pseudo_inv %*% y
#colnames(betahat) <- "regression coefficient"
#rownames(betahat) <- c("Sepal.Width","Patal.Length","Petal.Width","Species_versicolor","Species_virginica")
#print(betahat)
#lm(formula, data)
beta<-list()
beta$call=call("linear_model", formula,data)
beta$coefficients=qr.coef(qr(x),y)
class(beta)="lm"
return(beta)
}
linear_model(y~.,data=lm_patho)
library(test)
test()
install.packages("devtools")
library(devtools)
test()
library(bis557)
install.packages("bis557")
library(bis557)
library(devtools)
test()
library(devtools)
test()
test()
load("/Users/shawnieshan/Desktop/BIS557/bis557/data/lm_patho.rda")
#lmod<-lm(lm_patho$y~.,data=lm_patho)
#summary(lmod)
linear_model <- function(formula, data) {
#browser()
all<-all.vars(formula)
x<-model.matrix(formula, data)
y<-data[,all[1]]
#svd_output <- svd(x)
#U <- svd_output[["u"]]
#Sinv <- diag(1 / svd_output[["d"]])
#V <- svd_output[["v"]]
#pseudo_inv <- V %*% Sinv %*% t(U)
#betahat <- pseudo_inv %*% y
#colnames(betahat) <- "regression coefficient"
#rownames(betahat) <- c("Sepal.Width","Patal.Length","Petal.Width","Species_versicolor","Species_virginica")
#print(betahat)
#lm(formula, data)
beta<-list()
beta$call=call("linear_model", formula)
beta$coefficients=qr.coef(qr(x),y)
class(beta)="lm"
return(beta)
}
linear_model(y~.,data=lm_patho)
#library(bis557)
library(devtools)
test()
linear_model <- function(formula, data) {
#browser()
all<-all.vars(formula)
x<-model.matrix(formula, data)
y<-data[,all[1]]
#svd_output <- svd(x)
#U <- svd_output[["u"]]
#Sinv <- diag(1 / svd_output[["d"]])
#V <- svd_output[["v"]]
#pseudo_inv <- V %*% Sinv %*% t(U)
#betahat <- pseudo_inv %*% y
#colnames(betahat) <- "regression coefficient"
#rownames(betahat) <- c("Sepal.Width","Patal.Length","Petal.Width","Species_versicolor","Species_virginica")
#print(betahat)
#lm(formula, data)
beta<-list()
beta$call=call("linear_model", formula)
beta$coefficients=qr.coef(qr(x),y)
class(beta)="lm"
return(beta)
}
#linear_model(y~.,data=lm_patho)
#library(bis557)
library(devtools)
test()
install.
install.packages("test")
library(bis557)
sparse.matrix <- function(i, j, x, dims = c(max(i), max(j))){
#if (length(i) != length(j) || length(j) != length(x))
#stop("Incorrect dimensions.")
structure(list(data.frame(i = c(1, 2), j = c(1, 1), x = c(3, 1)), dims), class = "sparse.matrix")
}
sm0 <- sparse.matrix(i = c(1, 2), j = c(1, 1), x = c(1, 1))
sm0
install.packages(devtools)
install.packages("devtools")
#Generate a matrix X
X <- matrix(c(1, 1, 2, 0.3), nrow=2, ncol=2)
#Generate a propabilities p
p <- c(0.0000001, 0.1)
#According to textbook p27, calculate the condition number for X'X
s <- t(X) %*% X
svals <- svd(s)$d
max(svals)/min(svals)
#Calculate the condition number for logistic variation
var <- diag(p*(1-p))
H <- t(X) %*% var %*% X
svals_H <- svd(H)$d
max(svals_H)/min(svals_H)
#Conclusion:The conditional number for X'X is very small comparing to that of logistic variation. Therefore, X'X is a well-condition matrix but its logistic variation not.
#According to the textbook p129 coding
# X: A numeric data matrix.
# y: Response vector.
# family: Instance of an R 'family' object
# maxit: Integer maximum number of iterations.
# tol: Numeric tolerance parameter.
irwls_glm <-
function(X, y, family, maxit=25, tol=1e-10, lambda)
{
beta <- rep(0,ncol(X))
for(j in 1:maxit)
{
b_old <- beta
eta <- X %*% beta
mu <- family$linkinv(eta)
mu_p <- family$mu.eta(eta)
z <- eta + (y - mu) / mu_p
W <- as.numeric(mu_p^2 / family$variance(mu))
XtX <- crossprod(X, diag(W) %*% X)
Xtz <- crossprod(X, W * z)
beta <- solve(XtX + diag(lambda, dim(XtX)[1]), Xtz) #insert l2 norm
if(sqrt(crossprod(beta - b_old)) < tol) break
}
beta
}
library(bis557)
#library(bis557)
data(ridge_train)
data(ridge_test)
#build ridge function
#ridge_reg<-function(formula, data, lambda){
#m<-model.matrix(formula, data)
#y<-matrix(data[,as.character(formula)[2]],ncol=1)
#y<-y[as.numeric(rownames(m)),,drop=FALSE]
#Fit via svd
#svd_obj<-svd(m)
#U<-svd_obj$u
#V<-svd_obj$v
#svals<-svd_obj$d
#D<-diag(svals/(svals^2 +lambda))
#beta<-V %*% D %*% t(U) %*% y
#ret<- list(coefficients = beta, formula=formula, lambda=lambda)
#class(ret)<-"ridge_reg"
#return(ret)
#}
#ridge_train<-read.csv("/Users/shawnieshan/Desktop/ridge_train.csv")
#ridge_test<-read.csv("/Users/shawnieshan/Desktop/ridge_test.csv")
predict.ridge_reg<-function(object,...){
newdata<-list(...)[[1]]
m<-model.matrix(object$form,newdata)
m %*% object$coefficients
}
#library(MASS)
#library(foreach)
#library(doParallel)
#library(stats)
#formula<-y ~ x1 + x2 + x3 + x4
#lambda_seq<-seq(0.1,100,by=0.1)
#mses<-foreach(lambda=lambda_seq, .combine=c) %dopar% {
#fit<-ridge_reg(formula,ridge_train,lambda)
#error<-ridge_test$y-predict(fit,ridge_test)
#mean(error^2)
#}
#second way
lambda_seq=seq(0.1,100,by=0.1)
mses=rep(NA, length(lambda_seq))
for(i in 1:length(lambda_seq)){
fit=ridge_reg(y~.-1,lambda_seq[i],ridge_train)
error=ridge_test$y-predict(fit,ridge_test)
mses[i]=mean(error^2)
}
#library(bis557)
#data(ridge_train)
#data(ridge_test)
#build ridge function
#ridge_reg<-function(formula, data, lambda){
#m<-model.matrix(formula, data)
#y<-matrix(data[,as.character(formula)[2]],ncol=1)
#y<-y[as.numeric(rownames(m)),,drop=FALSE]
#Fit via svd
#svd_obj<-svd(m)
#U<-svd_obj$u
#V<-svd_obj$v
#svals<-svd_obj$d
#D<-diag(svals/(svals^2 +lambda))
#beta<-V %*% D %*% t(U) %*% y
#ret<- list(coefficients = beta, formula=formula, lambda=lambda)
#class(ret)<-"ridge_reg"
#return(ret)
#}
ridge_train<-read.csv("/Users/shawnieshan/Desktop/ridge_train.csv")
#library(bis557)
#data(ridge_train)
#data(ridge_test)
#build ridge function
#ridge_reg<-function(formula, data, lambda){
#m<-model.matrix(formula, data)
#y<-matrix(data[,as.character(formula)[2]],ncol=1)
#y<-y[as.numeric(rownames(m)),,drop=FALSE]
#Fit via svd
#svd_obj<-svd(m)
#U<-svd_obj$u
#V<-svd_obj$v
#svals<-svd_obj$d
#D<-diag(svals/(svals^2 +lambda))
#beta<-V %*% D %*% t(U) %*% y
#ret<- list(coefficients = beta, formula=formula, lambda=lambda)
#class(ret)<-"ridge_reg"
#return(ret)
#}
ridge_train<-read.csv("/Users/shawnieshan/Desktop/ridge_train.csv")
ridge_test<-read.csv("/Users/shawnieshan/Desktop/ridge_test.csv")
predict.ridge_reg<-function(object,...){
newdata<-list(...)[[1]]
m<-model.matrix(object$form,newdata)
m %*% object$coefficients
}
library(MASS)
library(foreach)
#library(doParallel)
#library(stats)
#formula<-y ~ x1 + x2 + x3 + x4
#lambda_seq<-seq(0.1,100,by=0.1)
#mses<-foreach(lambda=lambda_seq, .combine=c) %dopar% {
#fit<-ridge_reg(formula,ridge_train,lambda)
#error<-ridge_test$y-predict(fit,ridge_test)
#mean(error^2)
#}
#second way
lambda_seq=seq(0.1,100,by=0.1)
mses=rep(NA, length(lambda_seq))
for(i in 1:length(lambda_seq)){
fit=ridge_reg(y~.-1,lambda_seq[i],ridge_train)
error=ridge_test$y-predict(fit,ridge_test)
mses[i]=mean(error^2)
}
ridge_reg<-function(formula, lambda, data){
rownames(data) = NULL
m<-model.matrix(formula, data)
y<-matrix(data[,as.character(formula)[2]],ncol=1)
y<-y[as.numeric(rownames(m)),,drop=FALSE]
#Fit via svd
svd_obj<-svd(m)
U<-svd_obj$u
V<-svd_obj$v
svals<-svd_obj$d
D<-diag(svals/(svals^2 +lambda))
beta<-V %*% D %*% t(U) %*% y
rownames(beta) = colnames(m)
ret<- list(coefficients = beta, lambda=lambda,formula=formula)
class(ret)<-"ridge_reg"
ret
}
#library(bis557)
#data(ridge_train)
#data(ridge_test)
#build ridge function
#ridge_reg<-function(formula, data, lambda){
#m<-model.matrix(formula, data)
#y<-matrix(data[,as.character(formula)[2]],ncol=1)
#y<-y[as.numeric(rownames(m)),,drop=FALSE]
#Fit via svd
#svd_obj<-svd(m)
#U<-svd_obj$u
#V<-svd_obj$v
#svals<-svd_obj$d
#D<-diag(svals/(svals^2 +lambda))
#beta<-V %*% D %*% t(U) %*% y
#ret<- list(coefficients = beta, formula=formula, lambda=lambda)
#class(ret)<-"ridge_reg"
#return(ret)
#}
ridge_train<-read.csv("/Users/shawnieshan/Desktop/ridge_train.csv")
ridge_test<-read.csv("/Users/shawnieshan/Desktop/ridge_test.csv")
predict.ridge_reg<-function(object,...){
newdata<-list(...)[[1]]
m<-model.matrix(object$form,newdata)
m %*% object$coefficients
}
library(MASS)
library(foreach)
#library(doParallel)
#library(stats)
#formula<-y ~ x1 + x2 + x3 + x4
#lambda_seq<-seq(0.1,100,by=0.1)
#mses<-foreach(lambda=lambda_seq, .combine=c) %dopar% {
#fit<-ridge_reg(formula,ridge_train,lambda)
#error<-ridge_test$y-predict(fit,ridge_test)
#mean(error^2)
#}
#second way
lambda_seq=seq(0.1,100,by=0.1)
mses=rep(NA, length(lambda_seq))
for(i in 1:length(lambda_seq)){
fit=ridge_reg(y~.-1,lambda_seq[i],ridge_train)
error=ridge_test$y-predict(fit,ridge_test)
mses[i]=mean(error^2)
}
plot(log(lambda_seq), mses, xlab="log(lambda)", ylab="Out-of-Sample Mean Square Error")
lambda_seq[which.min(mses)]
#library(bis557)
#data(ridge_train)
#data(ridge_test)
#build ridge function
#ridge_reg<-function(formula, data, lambda){
#m<-model.matrix(formula, data)
#y<-matrix(data[,as.character(formula)[2]],ncol=1)
#y<-y[as.numeric(rownames(m)),,drop=FALSE]
#Fit via svd
#svd_obj<-svd(m)
#U<-svd_obj$u
#V<-svd_obj$v
#svals<-svd_obj$d
#D<-diag(svals/(svals^2 +lambda))
#beta<-V %*% D %*% t(U) %*% y
#ret<- list(coefficients = beta, formula=formula, lambda=lambda)
#class(ret)<-"ridge_reg"
#return(ret)
#}
ridge_train<-read.csv("/Users/shawnieshan/Desktop/ridge_train.csv")
ridge_test<-read.csv("/Users/shawnieshan/Desktop/ridge_test.csv")
predict.ridge_reg<-function(object,...){
newdata<-list(...)[[1]]
m<-model.matrix(object$form,newdata)
m %*% object$coefficients
}
library(MASS)
library(foreach)
#library(doParallel)
#library(stats)
#formula<-y ~ x1 + x2 + x3 + x4
#lambda_seq<-seq(0.1,100,by=0.1)
#mses<-foreach(lambda=lambda_seq, .combine=c) %dopar% {
#fit<-ridge_reg(formula,ridge_train,lambda)
#error<-ridge_test$y-predict(fit,ridge_test)
#mean(error^2)
#}
#second way
lambda_seq=seq(0.1,100,by=0.1)
mses=rep(NA, length(lambda_seq))
for(i in 1:length(lambda_seq)){
fit=ridge_reg(y~.-1,lambda_seq[i],ridge_train)
error=ridge_test$y-predict(fit,ridge_test)
mses[i]=mean(error^2)
}
plot(log(lambda_seq), mses, xlab="log(lambda)", ylab="Out-of-Sample Mean Square Error")
lambda_seq[which.min(mses)]
#library(bis557)
#data(ridge_train)
#data(ridge_test)
#build ridge function
#ridge_reg<-function(formula, data, lambda){
#m<-model.matrix(formula, data)
#y<-matrix(data[,as.character(formula)[2]],ncol=1)
#y<-y[as.numeric(rownames(m)),,drop=FALSE]
#Fit via svd
#svd_obj<-svd(m)
#U<-svd_obj$u
#V<-svd_obj$v
#svals<-svd_obj$d
#D<-diag(svals/(svals^2 +lambda))
#beta<-V %*% D %*% t(U) %*% y
#ret<- list(coefficients = beta, formula=formula, lambda=lambda)
#class(ret)<-"ridge_reg"
#return(ret)
#}
ridge_train<-read.csv("/Users/shawnieshan/Desktop/ridge_train.csv")
ridge_test<-read.csv("/Users/shawnieshan/Desktop/ridge_test.csv")
predict.ridge_reg<-function(object,...){
newdata<-list(...)[[1]]
m<-model.matrix(object$form,newdata)
m %*% object$coefficients
}
library(MASS)
library(foreach)
#library(doParallel)
#library(stats)
#formula<-y ~ x1 + x2 + x3 + x4
#lambda_seq<-seq(0.1,100,by=0.1)
#mses<-foreach(lambda=lambda_seq, .combine=c) %dopar% {
#fit<-ridge_reg(formula,ridge_train,lambda)
#error<-ridge_test$y-predict(fit,ridge_test)
#mean(error^2)
#}
ridge_reg<-function(formula, lambda, data){
rownames(data) = NULL
m<-model.matrix(formula, data)
y<-matrix(data[,as.character(formula)[2]],ncol=1)
y<-y[as.numeric(rownames(m)),,drop=FALSE]
#Fit via svd
svd_obj<-svd(m)
U<-svd_obj$u
V<-svd_obj$v
svals<-svd_obj$d
D<-diag(svals/(svals^2 +lambda))
beta<-V %*% D %*% t(U) %*% y
rownames(beta) = colnames(m)
ret<- list(coefficients = beta, lambda=lambda,formula=formula)
class(ret)<-"ridge_reg"
ret
}
#second way
lambda_seq=seq(0.1,100,by=0.1)
mses=rep(NA, length(lambda_seq))
for(i in 1:length(lambda_seq)){
fit=ridge_reg(y~.-1,lambda_seq[i],ridge_train)
error=ridge_test$y-predict(fit,ridge_test)
mses[i]=mean(error^2)
}
plot(log(lambda_seq), mses, xlab="log(lambda)", ylab="Out-of-Sample Mean Square Error")
lambda_seq[which.min(mses)]
library(devtools)
install.packages("usethis")
install.packages("usethis")
library(usethis)
install.packages("usethis")
